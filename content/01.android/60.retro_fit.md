---
title: Retrofitを扱う
description: Retrofitを使った実装方法を紹介・解説します。
navigation: true
draft: false
date: 2025-09-29T07:00:00+09:00
---

**`Retrofit`**は、Web API通信処理を実装するときのAndroidでデファクトスタンダードとなっているライブラリ。
通常JSONなどのデータをKotlin/Javaのデータクラスに自動でマッピングするため、**`Moshi`**などのコンバータライブラリと組み合わせて使用される。

#### 導入手順

以下の手順で導入する。

1. **`build.gradle`**にライブラリ（`Retrofit`と`Moshi`）を追加
2. **`AndroidManifest.xml`**に通信パーミッションを追加
3. 通信用インターフェースとデータクラスを定義
4. **`Retrofit`**インスタンスを生成し、通信処理を実行

-----

### 1\. `build.gradle`にライブラリを追加

`app/build.gradle`の`dependencies`に以下を追加する。

```gradle
dependencies {
    // moshiライブラリ。Jsonをデータオブジェクトに変換。
    implementation("com.squareup.moshi:moshi-kotlin:1.15.1") 
    // retrofit本体。通信処理を行うライブラリ。
    implementation("com.squareup.retrofit2:retrofit:2.11.0")
    // moshi-converter。RetrofitでMoshiを使えるようにする。
    implementation("com.squareup.retrofit2:converter-moshi:2.11.0")
}
```

### 2\. `AndroidManifest.xml`に通信パーミッションを追加

アプリが外部ネットワークと通信する場合、`AndroidManifest.xml`にインターネット接続のパーミッション宣言が必要。

```xml
<uses-permission android:name="android.permission.INTERNET" />
```

### 3\. 通信用インターフェースとレスポンスデータクラスの定義

今回は、[Sample APIs](https://sampleapis.com/api-list/coffee)のAPIを利用して、ホットコーヒーのリストを取得する例で進める。

#### 通信インターフェース

通信処理の詳細（HTTPメソッドやエンドポイントのパス）を定義した**インターフェース**を追加する。

  * `@GET`アノテーションでHTTPメソッド（GET）とパス（`/coffee/hot`）を指定する。
  * 返り値は`Call<List<Coffee>>`とし、`Retrofit`に非同期通信の準備をする。

```kotlin
interface ApiInterface {
    @GET("/coffee/hot")
    fun hotCoffee(): Call<List<Coffee>>
}
```

#### レスポンスデータクラス

APIから返ってくるJSONデータに対応する**データクラス**を定義する。今回は簡単のため、`title`フィールドのみを解析対象とする。

```kotlin
data class Coffee(val title: String)
```

### 4\. Retrofitインスタンスの生成と通信処理の実行

#### Retrofitインスタンスの生成

`Retrofit.Builder()`を使ってインスタンスを生成する。

  * `baseUrl`：接続先のドメインを指定する。
  * `addConverterFactory`：JSONパーサーとして**`MoshiConverterFactory`**を設定する。

```kotlin
val retrofit = Retrofit.Builder()
    .baseUrl("https://api.sampleapis.com")
    .addConverterFactory(
        MoshiConverterFactory.create(
            Moshi.Builder()
                .add(KotlinJsonAdapterFactory())
                .build()
        )
    )
    .build()
```

#### 通信処理の実行

前項で生成した`retrofit`インスタンスに先ほど定義した`ApiInterface`を渡して、実際に通信を行うインスタンスを生成する。

```kotlin
val api = retrofit.create(ApiInterface::class.java)
```

この`api`インスタンスのメソッドを呼び出し、**`enqueue()`**メソッドを使って通信を非同期で依頼する。
`enqueue()`は、通信結果をメインスレッドで受け取るためのコールバック（`Callback`）を引数に取る。

```kotlin
api.hotCoffee().enqueue(object : Callback<List<Coffee>> {
    override fun onResponse(p0: Call<List<Coffee>>, response: Response<List<Coffee>>) {
        Log.d("RetrofitActivity", "response.isSuccessful:${response.isSuccessful}")
        Log.d("RetrofitActivity", "response.code:${response.code()}")
        Log.d("RetrofitActivity", "response.body:${response.body()}") // ここにパースされたデータが入る
    }
    
    override fun onFailure(p0: Call<List<Coffee>>, error: Throwable) {
        // エラーハンドリング
        Log.w("RetrofitActivity", "onFailure", error)
    }
})
```

#### 注意点

同じ通信依頼メソッドとして`execute()`もある。
こちらは**同期処理**で、Androidではメインスレッドでのネットワーク通信はクラッシュするため、非同期処理の`enqueue()`の利用が基本。
