---
title: Activityを扱う
description: Activityに関する実装を紹介・解説します。
navigation: true
draft: false
date: 2025-9-13T07:00:00+09:00
---

## Activityを追加する

最小単位で必要な作業は以下2つ。

1. `AppComatActivity` を継承したクラスを新規作成する。
2. `AndroidManifest.xml`に定義を追加する。

### Activityクラスの新規作成

`AppComatActivity` を継承したクラスを追加する。

例えば、`CustomActivity` を実装する。
実装はどこでも問題ないが、Activityであれば専用のファイル（`CustomActivity.kt`）を作成するのが自然。 

```
class CustomActivity : AppCompatActivity() {
}
```

### AndroidManifest.xmlに定義の追加

前項で実装した`CustomActivity`の定義を`AndroidManifest.xml`に追加する。

定義は`<application>`タグ内に追加する。
```
<application
  ... 
  ...>
  <activity android:name="com.mkt120.sampleapplication.CustomActivity" />

</application>
```

新規プロジェクトを作成すると、`MainActivity`がすでに定義されているので、それを参考にすると良い。



## Activityを開始する

`startActivity`を使う。

例えばボタンをタップした時に、1つめの画面（`MainActivity`）から2つめの画面(`CustomActivity`)を開始する場合は以下。

```kt
  findViewById<View>(R.id.button_start_activity).setOnClickListener {
      val intent = Intent(context, CustomActivity::class.java)
      startActivity(intent)
  }
```

## Activityを開始し、その結果を受け取る

`ActivityResultLauncher.launch`を使う。

2つめの`Activity`の処理結果を1つめの`Activity`で受け取りたい場合、`startActivity`で開始すると結果を受け取ることができない。

`ActivityResultLauncher.launch`を使って`Activity`を開始し、2つめの`Activity`の処理結果を受け取る処理を実装しておく。

例えば2つめの画面として、`CustomActivity`を以下のように実装する。

```kt
class CustomActivity : AppCompatActivity() {

    companion object {
        const val EXTRA_RESULT_DATA = "extra_result_data"
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_startactivity_custom)

        val button1 = findViewById<Button>(R.id.button_1)
        button1.setOnClickListener {
            // 処理結果をintentに設定してActivityを終了する
            val data = Intent().apply {
                putExtra(EXTRA_RESULT_DATA, button1.text.toString())
            }
            setResult(RESULT_OK, data)
            finish()
        }
        val button2 = findViewById<Button>(R.id.button_2)
        button2.setOnClickListener {
            // 処理結果をintentに設定してActivityを終了する
            val data = Intent().apply {
                putExtra(EXTRA_RESULT_DATA, button2.text.toString())
            }
            setResult(RESULT_OK, data)
            finish()
        }
    }

}
```

`res/activity_startactivity_custon.xml`として以下を追加する。

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:gravity="center"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/button_1"
        android:layout_width="wrap_content"
        android:text="ボタン1"
        android:layout_height="wrap_content"/>

    <Button
        android:id="@+id/button_2"
        android:layout_width="wrap_content"
        android:text="ボタン2"
        android:layout_height="wrap_content"/>

</LinearLayout>
```

1つ目の画面で`CustomActivity`を開始するため、`ActivityResultLauncher`を生成する。
`ActivityResultLauncher`は`registerForActivityResult`を利用する。

```kt
  private val activityResultLauncher = registerForActivityResult(StartActivityForResult()) { result ->
    if (result.resultCode != RESULT_OK) {
      // キャンセルされた
      return@registerForActivityResult
    }
    val data = result.data?.getStringExtra(CustomActivity.EXTRA_RESULT_DATA)
    val textView = findViewById<TextView>(R.id.text_view_result)
    textView.text = "$data:がタップされました"
  }
```

生成した`ActivityResultLauncher`で`CustomActivity`を開始する。

```kt
  findViewById<View>(R.id.button_register_activity_for_result).setOnClickListener {
    val intent = Intent(context, CustomActivity::class.java)
    activityResultLauncher.launch(intent)
  }
```


### 補足：startActivityForResultについて

`startActivityForResult`は`ActivityResultLauncher`が追加される前に利用されていた機能で、現在はdeprecated(非推奨)となっている。

### 参考

- [Activity  |  API reference  |  Android Developers](https://developer.android.com/reference/android/app/Activity)
- [ActivityResultCaller  |  API reference  |  Android Developers](https://developer.android.com/reference/androidx/activity/result/ActivityResultCaller#registerForActivityResult(androidx.activity.result.contract.ActivityResultContract,androidx.activity.result.ActivityResultCallback))

## Activityを透明にする

`AndroidManifest.xml`でその`Activity`に**テーマ**を適用する。

`styles.xml`で透明な`Activity`用のテーマを定義する。

```xml
<style name="TransparentActivityTheme" parent="AppTheme.NoActionBar">
    <item name="android:windowBackground">@android:color/transparent</item>
    <item name="android:colorBackgroundCacheHint">@null</item>
    <item name="android:windowIsTranslucent">true</item>
</style>
```

追加したテーマを適用することで、その`Activity`を透明にできる。

```xml
<activity
    android:name="com.sample.application.TransparentActivity"
    android:theme="@style/TransparentActivityTheme"/>
```

### 注意点：`orientation`を指定するとクラッシュする

透明な`Activity`の利用時には重要な注意点がある。
`AndroidManifest.xml`で`android:screenOrientation`を指定したり、プログラムで画面の向き（`orientation`）を設定すると、アプリがクラッシュする。
これは透明な`Activity`が親の`Activity`の向きに依存する仕様があるため。

透明な`Activity`を使用する際は、**画面の向きに関する設定を行わない**こと。

### 参考

  * [\<activity\> | Android Developers](https://developer.android.com/guide/topics/manifest/activity-element)
  * [透明Activityの罠 - Studyplus Engineering Blog](https://tech.studyplus.co.jp/entry/2018/12/10/125101)